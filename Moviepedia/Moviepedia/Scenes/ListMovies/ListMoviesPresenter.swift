//
//  ListMoviesPresenter.swift
//  Moviepedia
//
//  Created by Lucas Ferraço on 29/08/18.
//  Copyright (c) 2018 Lucas Ferraço. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ListMoviesPresentationLogic {
	func presentMoviesList(with response: ListMovies.ListMovies.Response)
	func presentMovieImage(with response: ListMovies.GetMovieImage.Response, _ completion: @escaping (UIImage) -> Void)
	func presentNewMovies(with response: ListMovies.GetMoreMovies.Response, _ completion: @escaping ([ListMovies.DisplayableMovieInfo]) -> Void)
}

class ListMoviesPresenter: ListMoviesPresentationLogic {
	weak var viewController: ListMoviesDisplayLogic?
	
	private var presentedMoviesInfo: [ListMovies.DisplayableMovieInfo] = []
	
	//MARK:- ListMoviesPresentationLogic protocol
	
	func presentMoviesList(with response: ListMovies.ListMovies.Response) {
		let moviesInfo = response.movies?.map { (movie) -> ListMovies.DisplayableMovieInfo in
			return displayableInfo(from: movie, genreDictionary: response.genres)
		}
		
		if let moviesInfo = moviesInfo {
			presentedMoviesInfo = moviesInfo
		}
		
		var errorMessage: String? = nil
		if let error = response.error {
			errorMessage = message(for: error)
		}
		
		let viewModel = ListMovies.ListMovies.ViewModel(moviesInfo: moviesInfo, errorMessage: errorMessage)
		
		// UI operations should only be done on the main thread
		DispatchQueue.main.async {
			self.viewController?.displayMoviesList(with: viewModel)
		}
	}
	
	func presentMovieImage(with response: ListMovies.GetMovieImage.Response, _ completion: @escaping (UIImage) -> Void) {
		var movieImage: UIImage
		if let image = response.movieImage {
			var presentedMovie = presentedMoviesInfo.first { (movieInfo) -> Bool in
				return response.movieId == movieInfo.id
			}
			presentedMovie?.image = image
			
			movieImage = image
		} else {
			movieImage = #imageLiteral(resourceName: "defaultMovieImage.png")
		}
		
		DispatchQueue.main.async {
			completion(movieImage)
		}
	}
	
	func presentNewMovies(with response: ListMovies.GetMoreMovies.Response, _ completion: @escaping ([ListMovies.DisplayableMovieInfo]) -> Void) {
		guard let moviesInfo = response.newMovies else { return }
		
		let newMovies = moviesInfo.map { (movie) -> ListMovies.DisplayableMovieInfo in
			return displayableInfo(from: movie, genreDictionary: response.genres)
		}
		
		presentedMoviesInfo += newMovies
		DispatchQueue.main.async {
			completion(newMovies)
		}
	}
	
	//MARK:- Auxiliary methods
	
	private func displayableInfo(from movie: Movie, genreDictionary: [Int : String]?) -> ListMovies.DisplayableMovieInfo {
		let id = movie.id ?? -1
		
		var movieTitle = ""
		if let title = movie.title {
			movieTitle = title
		} else if let originalTitle = movie.originalTitle {
			movieTitle = originalTitle
		}
		
		var genresString = ""
		if let genreIds = movie.genreIds {
			let genreIdsReduced = genreIds.reduce(into: "", { (genresString, id) in
				if let genreName = genreDictionary?[id] {
					genresString += genreName + ", "
				}
			}).dropLast(2)
			
			genresString = String(genreIdsReduced)
		}
		
		var releaseDate = ""
		if let dateObj = movie.releaseDate {
			releaseDate = DateFormatter.localizedString(from: dateObj, dateStyle: .short, timeStyle: .none)
		}
		
		return ListMovies.DisplayableMovieInfo(id: id, title: movieTitle, image: nil, genre: genresString, releaseDate: releaseDate)
	}
	
	private func message(for error: MoviesAPIWorkerError) -> String {
		switch error {
		case .NoConnection:
			return "No internet connection.\nConnect to a network and try again."
		case .Failure:
			return "We had problems fetching the movies info, please try again later."
		case .AllMoviesDownloaded:
			return "All movies were already downloaded, enjoy!"
		}
	}
}
