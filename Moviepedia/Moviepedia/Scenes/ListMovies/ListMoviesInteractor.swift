//
//  ListMoviesInteractor.swift
//  Moviepedia
//
//  Created by Lucas Ferraço on 29/08/18.
//  Copyright (c) 2018 Lucas Ferraço. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ListMoviesBusinessLogic {
	func getUpcomingMovies()
	func getMovieImage(with request: ListMovies.GetMovieImage.Request, _ completion: @escaping (UIImage) -> Void)
	func getMoreMovies(_ completion: @escaping ([ListMovies.DisplayableMovieInfo]) -> Void)
	func storeSelectedMovie(with id: Int)
}

protocol ListMoviesDataStore {
	var movie: Movie! { get set }
}

class ListMoviesInteractor: ListMoviesBusinessLogic, ListMoviesDataStore {
	var presenter: ListMoviesPresentationLogic?
	
	var moviesDictionary: [Int : Movie] = [:]
	var moviesWorker = MoviesAPIWorker.shared
	private var nextPage = 1
	private var lastPage = 1
	
	var genreWorker = GenreAPIWorker.shared
	var downloadImageWorker = DownloadImageAPIWorker.shared
	
	// MARK:- ListMoviesDataStore protocol
	
	var movie: Movie!
	
	// MARK:- ListMoviesBusinessLogic protocol
	
	func getUpcomingMovies() {
		moviesWorker.fetchMoviesList(of: .upcoming) { (response, error) in
			let movies = response?.movies
			if let response = response {
				self.moviesDictionary.removeAll()
				self.store(requestInfo: response)
			}
			
			self.genreWorker.fetchGenres(of: .movie) { (genreList) in
				var genreDict: [Int : String]? = [:]
				
				if let genreList = genreList {
					for genre in genreList {
						genreDict?.updateValue(genre.name, forKey: genre.id)
					}
				} else {
					genreDict = nil
				}
			
				let response = ListMovies.ListMovies.Response(movies: movies, genres: genreDict, error: error)
				self.presenter?.presentMoviesList(with: response)
			}
		}
	}
	
	func getMovieImage(with request: ListMovies.GetMovieImage.Request, _ completion: @escaping (UIImage) -> Void) {
		let chosenMovie = moviesDictionary[request.movieId]
		
		if let posterImage = chosenMovie?.posterImage {
			present(image: posterImage, id: request.movieId, completion)
			return
		} else if let backdropImage = chosenMovie?.backdropImage {
			present(image: backdropImage, id: request.movieId, completion)
			return
		}
		
		let (path, imageType) = getImagePath(for: chosenMovie)
		
		guard !path.isEmpty else {
			self.present(image: nil, id: request.movieId, completion)
			return
		}
		
		downloadImageWorker.downloadImage(from: path, type: imageType) { (callbackPath, image) in
			switch imageType {
			case .poster:
				chosenMovie?.posterImage = image
			case .backdrop:
				chosenMovie?.backdropImage = image
			}
			
			if callbackPath == path { // Avoid the image to load on the wrong spot
				self.present(image: image, id: request.movieId, completion)
			}
		}
	}
	
	func getMoreMovies(_ completion: @escaping ([ListMovies.DisplayableMovieInfo]) -> Void) {
		if nextPage > lastPage {
			let response = ListMovies.GetMoreMovies.Response(newMovies: nil, genres: nil, error: .AllMoviesDownloaded)
			self.presenter?.presentNewMovies(with: response, completion)
			return
		} else {
			nextPage += 1 // Keeps the user from fetching the same page twice
		}
		
		moviesWorker.fetchMoviesList(of: .upcoming, on: nextPage - 1) { (response, error) in
			let movies = response?.movies
			if let response = response {
				self.store(requestInfo: response)
			}
			
			self.genreWorker.fetchGenres(of: .movie) { (genreList) in
				var genreDict: [Int : String]? = [:]
				
				if let genreList = genreList {
					for genre in genreList {
						genreDict?.updateValue(genre.name, forKey: genre.id)
					}
				} else {
					genreDict = nil
				}
				
				let response = ListMovies.GetMoreMovies.Response(newMovies: movies, genres: genreDict, error: error)
				self.presenter?.presentNewMovies(with: response, completion)
			}
		}
	}
	
	func storeSelectedMovie(with id: Int) {
		movie = moviesDictionary[id]
	}
	
	//MARK:- Auxiliary Methods
	
	private func store(requestInfo response: MoviesAPIWorker.MoviesListResponse) {
		if nextPage != response.page + 1 {
			nextPage = response.page + 1
		}
		lastPage = response.totalPages
		
		for i in 0..<response.movies.count {
			let currentMovie = response.movies[i]
			
			if let id = currentMovie.id {
				self.moviesDictionary.updateValue(currentMovie, forKey: id)
			} else {
				self.moviesDictionary.updateValue(currentMovie, forKey: i)
			}
		}
	}
	
	private func present(image: UIImage?, id: Int, _ completion: @escaping (UIImage) -> Void) {
		let response = ListMovies.GetMovieImage.Response(movieId: id, movieImage: image)
		self.presenter?.presentMovieImage(with: response, completion)
	}
	
	private func getImagePath(for movie: Movie?) -> (path: String, type: DownloadImageAPIWorker.ImageType) {
		var path = ""
		var imageType: DownloadImageAPIWorker.ImageType = .poster
		if let posterPath = movie?.posterPath {
			path = posterPath
		} else if let backdropPath = movie?.backdropPath {
			path = backdropPath
			imageType = .backdrop
		}
		
		return (path, imageType)
	}
}
